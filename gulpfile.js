"use strict"
const app = ('app/') // Папка с сырыми файлами.
const build = ('build/') // Папка готовой сборки.
const config = require('./config.js') // Содержит пути к файлам.
const { src, dest, series, watch } = require('gulp') // Gulp.
const include = require('gulp-file-include') // Пакет для соединения файлов.
const concat = require('gulp-concat') // Объединит файлы в один файл, в том порядке, в котором они указаны, в gulp.src функции.
const browserSync = require('browser-sync').create() // Вызываем методо create чтобы сервер работал.
const del = require('del') // Удалить файлы и каталоги.
const size = require('gulp-size') // Регистрирует общий размер файлов в потоке и возможно отдельные размеры файлов. Размер фалов будет показан в терминале при сборке.
const ttf2woff = require('gulp-ttf2woff') // Конвертировать шрифт из ttf в woff.
const ttf2woff2 = require('gulp-ttf2woff2') // Конвертировать шрифт из ttf в woff2.
const pxtorem = require('postcss-pxtorem') // Плагин который генерирует единицы rem из единиц px.
const posthtmlPostcss = require('posthtml-postcss') // Использовать PostCSS в HTML.
const htmlMinify = require('html-minifier') // HTML-минификатор на основе JavaScript.
const postcss = require('gulp-postcss') // Для передачи CSS через несколько плагинов.
const autoprefixer = require('autoprefixer') // Добавление автопрефиксов поставщиков в правила CSS.
const CleanCSS = require('clean-css'); // Это быстрый и эффективный оптимизатор CSS он минифицирет файл.
const sass = require('gulp-sass')(require('sass')); // CSS препроцессер SCSS.
const babel = require('gulp-babel') // Компилятор JS. Набор инструментов для преобразования кода ECMAScript 2015+ в обратно совместимую версию JS в текущих и старых браузерах.
const babelPresetEnv = require('@babel/preset-env') // Это интеллектуальная предустановка, которая позволяет использовать последнюю версию JS без необходимости микроуправления.
const terser = require('gulp-terser') // Инструмент для сжатия JavaScript для ES6 +. На замену старому (gulp-uglify).
const posthtml = require('gulp-posthtml') // Это инструмент для преобразования HTML/XML с помощью плагинов JS.
    // const replace = require('replace-in-file') // Простая утилита для быстрой замены текста в одном или нескольких файлах.
    // const sass = require('sass')


const config_size = { // Получаем размер файла.
    showFiles: false, // Отображает размер каждого файла, а не только общий размер.
    showTotal: true, // Отображает общее количество всех файлов.
    pretty: true, // Отображает предварительно заданный размер: 1337 Б → 1,34 КБ.я
    gzip: false, // Отображает размер в сжатом виде.
}

const config_HTML_size = { title: '-------------------------------------------- HTML: ' }
const config_CSS1_size = { title: '-------------------------------------------- libs.min.css: ' }
const config_CSS2_size = { title: '-------------------------------------------- style.min.css: ' }
const config_FONTS_size = { title: '-------------------------------------------- FONTS: ' }
const config_JS1_size = { title: '-------------------------------------------- libs.min.js: ' }
const config_JS2_size = { title: '-------------------------------------------- main.min.js: ' }
const config_IMG_size = { title: '-------------------------------------------- IMG: ' }
const config_ALL_size = { title: '-------------------------------------------- All project: ' }

// Компилирует HTML файлы
function html() {
    const postcssPlugins = [
        autoprefixer({
            overrideBrowserslist: [
                '>0.25%',
                'not ie 11',
                'not op_mini all'
            ]
        }),
        pxtorem({
            rootValue: 16,
            unitPrecision: 5,
            propList: ['font', 'font-size', 'line-height', 'letter-spacing'],
            replace: false,
            mediaQuery: false,
            minPixelValue: 0,
        })
    ];
    const postcssOptions = { from: undefined }
    const filterType = /^text\/css$/
    const plugins = [
        // Подключаем плагины 'autoprefixer' и 'pxtorem' через плагин 'posthtml-postcss'. В опциях для PostCss выставляем значение 'undefined' для отключения ошибки.
        posthtmlPostcss(postcssPlugins, postcssOptions, filterType)
    ];
    const options = {
        includeAutoGeneratedTags: true, // Вставить теги, созданные парсером HTML.
        // quoteCharacter: '', // Тип цитаты для значений атрибутов ('или ").
        // minifyCSS: true,
        // minifyJS: minify_es6,
        removeAttributeQuotes: true, // По возможности удаляет кавычки вокруг атрибутов.
        removeComments: true, // Убрать HTML-комментарии.
        removeRedundantAttributes: true, // Удалять атрибуты, когда значение соответствует поумолчанию.
        removeScriptTypeAttributes: true, // Удалить type="text/javascript"из scriptтегов. Остальные typeзначения атрибутов остаются без изменений.
        removeStyleLinkTypeAttributes: true, // Удалить type="text/css"из styleи linkтеги. Остальные typeзначения атрибутов остаются без изменений.
        sortClassName: true, // Сортировать классы стилей по частоте.
        useShortDoctype: true, // Заменяет на doctypeкороткий (HTML5) doctype.
        collapseWhitespace: true // Свернуть пустое пространство, которое используется в текстовых узлах в дереве документа.
    }

    return src(config.app.html)
        .pipe(include({ prefix: '@@' })) // Подключаем через @@include() файлы html к основному.
        .pipe(posthtml(plugins)) // Это инструмент для преобразования HTML/XML с помощью плагинов JS.
        .on('data', function(file) { // HTML-минификатор на основе JavaScript.
            const buferFile = Buffer.from(htmlMinify.minify(file.contents.toString(), options))
            file.contents = buferFile;
            return;
        })
        .pipe(dest(config.build.html)) // Перемещаем в папку готовой сборки.
}


function scss() {
    const options = {
        compatibility: '*', // (по умолчанию) - режим совместимости с Internet Explorer 10+
        inline: ['all'], // включает все встраивание, так же как ['local', 'remote']
        level: 2 // Уровни оптимизации. Опция может быть 0, 1( по умолчанию), или 2, например
    };
    const plugins = [
        autoprefixer({
            // browsers: 'last 1 version'
            overrideBrowserslist: [
                '>0.25%',
                'not ie 11',
                'not op_mini all'
            ]
        }),
        pxtorem({
            rootValue: 16, // Представляет размер шрифта корневого элемента.
            unitPrecision: 5, // Десятичные числа, до которых могут вырасти единицы REM.
            propList: ['font', 'font-size', 'line-height', 'letter-spacing'], // Свойства, которые могут изменяться с px на rem.
            replace: false, // Заменяет правила, содержащие rems, вместо добавления резервных вариантов.
            mediaQuery: false, // Разрешить преобразование px в медиа-запросах.
            minPixelValue: 0, // Установите минимальное значение заменяемого пикселя.
        })
    ];

    return src(config.app.style, { sourcemaps: true }) // Значение { sourcemaps: true } позволяет сгенерировать исходные карты.
        .pipe(sass.sync().on('error', sass.logError)) // Скомпилировали SCSS в CSS.
        .pipe(concat('style.min.css')) // Объединяем CSS файлы в один файл.
        .pipe(postcss(plugins))
        .on('data', function(file) { // Это быстрый и эффективный оптимизатор CSS.
            const buferFile = new CleanCSS(options).minify(file.contents)
            return file.contents = Buffer.from(buferFile.styles)
        })
        .pipe(dest(config.build.style, { sourcemaps: '../sourcemaps/' })) // Перемещаем в папку готовой сборки.
}

// Заменяем все найденный строки в style.min.css.
// function updateRedirects(done) {
//     replace({
//         files: 'build/css/style.min.css',
//         from: /img\/sprite.png/g, // Ищем эти строки img/sprite.png
//         to: '../img/sprite.png', // Заменяем на ../img/sprite.png
//         countMatches: true,
//     }, done)
// }

// Компилирует JavaScript файлы
function javaScript() {
    return src(config.app.js, { sourcemaps: true })
        .pipe(babel({ // Скомпилировали ECMAScript 2015+ в совместимый JS.
            presets: [babelPresetEnv]
        }))
        .pipe(terser()) // Минифицируем JS файлы.
        .pipe(concat('main.min.js')) // Объединяем CSS файлы в один файл.
        .pipe(dest(config.build.js, { sourcemaps: '../sourcemaps/' }))

}

// Конвертирует шрифт
function fontConverter() {
    return src(config.app.fonts)
        .pipe(ttf2woff()) // Конвертирует шрифт ttf в woff
        .pipe(src(config.app.fonts))
        .pipe(ttf2woff2()) // Конвертирует шрифт ttf в woff2
        .pipe(dest(config.build.fonts))
}

// Клонируем изображения
function imgConverter() {
    return src(config.app.img)
        .pipe(dest(config.build.img))
}

//—————————————————————— Подключаем CSS файлы и минифицируем их в libs.min.css ——————————————————————
function css() {
    const plugins = [
        autoprefixer({
            overrideBrowserslist: [
                '>0.25%',
                'not ie 11',
                'not op_mini all'
            ]
        })
    ];
    return src(['node_modules/normalize.css/normalize.css'], { sourcemaps: true })
        .pipe(postcss(plugins))
        .pipe(concat('libs.min.css'))
        .on('data', function(file) {
            const buferFile = new CleanCSS(options).minify(file.contents)
            return file.contents = Buffer.from(buferFile.styles)
        })
        .pipe(dest(config.build.style, { sourcemaps: '../sourcemaps/' }))
}
//—————————————————————— Подключаем JS файлы и минифицируем их в libs.min.js ——————————————————————
function js() {
    return src(['node_modules/jquery/dist/jquery.js'], { sourcemaps: true })
        .pipe(babel({
            presets: [babelPresetEnv]
        }))
        .pipe(terser())
        .pipe(concat('libs.min.js'))
        .pipe(dest(config.build.js, { sourcemaps: '../sourcemaps/' }))
}

// Получаем размеры файлов в готовой сборке 
function htmlSize() {
    return src(build + '**/*.html')
        .pipe(size(Object.assign(config_size, config_HTML_size)))
}

function cssSize1() {
    return src(config.build.style + '/libs.min.css')
        .pipe(size(Object.assign(config_size, config_CSS1_size)))
}

function cssSize2() {
    return src(config.build.style + '/style.min.css')
        .pipe(size(Object.assign(config_size, config_CSS2_size)))
}

function jsSize1() {
    return src(config.build.js + '/libs.min.js')
        .pipe(size(Object.assign(config_size, config_JS1_size)))
}

function jsSize2() {
    return src(config.build.js + '/main.min.js')
        .pipe(size(Object.assign(config_size, config_JS2_size)))
}

function fontSize() {
    return src(config.build.fonts + '/**.*')
        .pipe(size(Object.assign(config_size, config_FONTS_size)))
}

function imgSize() {
    return src(config.build.img + '/**.*')
        .pipe(size(Object.assign(config_size, config_IMG_size)))
}

function allSize() {
    return src(build + '**/*.*')
        .pipe(size(Object.assign(config_size, config_ALL_size)))
}

// Очищаем папку build перед каждым запуском сборки.
function clear() {
    return del(build)
}

function stream() {
    browserSync.init({
            server: build, // Запускаем сервер из папки build, уже сгенерированный сайт.
            host: 'localhost', // Переопределить определение хоста, если вы знаете правильный IP-адрес для использования.
            notyfy: false, // Не показывать уведомления в браузере. Небольшие всплывающие уведомления.
            browser: "chrome", // Откройте сайт в Chrome.
            logPrefix: 'My Project:', // Измените префикс ведения журнала консоли. Полезно, если вы создаете свой собственный проект на основе Browsersync.
            logLevel: 'info', // Просто покажите основную информацию.
            open: "local", // Откройте URL-адрес localhost. Решите, какой URL-адрес будет открываться автоматически при запуске Browsersync.
            port: 8080 // Использовать определенный порт (вместо того, который автоматически определяется Browsersync).
        })
        // Следит за обновлениями html, scss и п.р. файлов. Если произошли изменения тогда вызываем задачу series(). И перезагружаем сервер.
    watch(config.watch.html, series(html)).on('change', browserSync.reload)
    watch(config.watch.style, series(scss)).on('change', browserSync.reload)
        // watch(config.watch.style, series(css)).on('change', browserSync.reload)
    watch(config.watch.js, series(javaScript)).on('change', browserSync.reload)
    watch(config.watch.js, series(js)).on('change', browserSync.reload)
    watch(config.watch.fonts, series(fontConverter)).on('change', browserSync.reload)
    watch(config.watch.img, series(imgConverter)).on('change', browserSync.reload)
}

// Экспортируем задачи для сборки проекта или запуска в режиме разработки.
// series - Объединяет функции задач и составные операции в более крупные операции, которые будут выполняться одна за другой в последовательном порядке.
// Вызываем по очерёдно задачи. Gulp build.
exports.build = series(clear, fontConverter, html, scss, css, javaScript, js, imgConverter, htmlSize, cssSize1, cssSize2, fontSize, jsSize1, jsSize2, imgSize, allSize)
    // Очищаем папку build, компилируем файлы и запускаем сервер stream. Gulp stream.
exports.stream = series(clear, fontConverter, html, scss, css, javaScript, js, imgConverter, htmlSize, cssSize1, cssSize2, fontSize, jsSize1, jsSize2, imgSize, allSize, stream)
exports.clear = clear()